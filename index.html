<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8" /> <meta name="viewport" content="width=device-width,initial-scale=1.0"/> <title>Million Pixel — Grid</title> <style> :root{ --bg:#0f0f10; --panel:#141416; --accent:#0f0; --muted:#7b7b7b; --avail:#333; --purchased:#0a8f3a; --selected:#16c516; --hover:#00a3ff; } *{box-sizing:border-box} body{margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:var(--bg);color:#eee;overflow:hidden} nav{position:fixed;left:0;right:0;top:0;height:56px;background:#151515;display:flex;align-items:center;padding:8px 12px;z-index:40} nav img{height:34px;margin-right:10px} nav h1{color:var(--accent);font-size:18px;margin:0 14px 0 0} nav .spacer{flex:1} button, input, select, textarea{font-family:inherit;font-size:14px} /* canvas area */ #canvasContainer{position:absolute;top:56px;left:0;right:0;bottom:0;background:var(--bg);overflow:hidden} canvas{display:block; width:100%; height:100%; background:transparent; cursor:crosshair} /* sidebar */ #sidebar{position:fixed;top:56px;right:-360px;width:360px;bottom:0;background:var(--panel);border-left:1px solid #222;padding:12px;overflow-y:auto;transition:right .25s;z-index:45} #sidebar.open{right:0} #sidebar h2{margin:6px 0 10px 0} /* pixel item */ .pixelSection{display:flex;gap:8px;align-items:flex-start;border:1px solid #222;padding:8px;border-radius:8px;margin-bottom:8px;background:#111;position:relative} .pixelSection img{width:56px;height:56px;object-fit:cover;border-radius:4px} .pixelMeta{flex:1;font-size:13px} .pixelMeta input{width:100%;margin-top:6px;padding:6px;border-radius:6px;border:1px solid #222;background:#0b0b0b;color:#fff} .removePixel{position:absolute;top:6px;right:6px;background:#cc3333;border:none;color:#fff;border-radius:50%;width:24px;height:24px;cursor:pointer} /* small controls */ .controls{position:fixed;top:64px;right:380px;z-index:46;display:flex;flex-direction:column;gap:8px} .controlBtn{background:var(--accent);color:#0b0b0b;border:none;padding:10px 12px;border-radius:8px;cursor:pointer} .small{padding:8px 10px;font-size:13px} /* minimap */ #minimapWrap{position:fixed;left:12px;bottom:12px;background:rgba(0,0,0,0.45);padding:8px;border-radius:8px;border:1px solid #222;z-index:46} #minimap{width:160px;height:160px;display:block;background:#0b0b0b;border-radius:4px} /* magnifier */ #magnifier{position:fixed;pointer-events:none;z-index:50;border-radius:8px;overflow:hidden;border:2px solid rgba(255,255,255,0.08);display:none;background:#000} /* footer/help */ .footer{position:fixed;left:12px;top:12px;background:rgba(0,0,0,0.35);padding:6px 10px;border-radius:6px;border:1px solid #222;font-size:13px;z-index:46} </style> </head> <body> <nav> <img src="https://via.placeholder.com/34" alt="logo"> <h1>Million Pixel</h1> <div class="spacer"></div> <button id="fsBtn" class="small">Full screen</button> </nav> <div id="canvasContainer"> <canvas id="pixelCanvas"></canvas> </div> <!-- sidebar --> <div id="sidebar" aria-hidden="true"> <h2>Selected Pixels</h2> <label style="display:flex;align-items:center;gap:8px;margin-bottom:8px"> <input type="checkbox" id="singleLink"> Use one hyperlink for all pixels </label> <div style="display:flex;gap:8px;margin-bottom:8px"> <button id="bulkApply" class="controlBtn">Bulk apply image/link</button> <button id="boxSelectToggle" class="controlBtn">Box Select</button> </div> <div id="pixelList"></div> <div id="totalCost" style="margin-top:8px;font-weight:700">Total Cost: 0 JOD</div> <button id="checkout" style="margin-top:10px;padding:10px;border-radius:8px;border:none;background:var(--accent);color:#000;font-weight:700">Checkout</button> <div style="margin-top:12px;color:var(--muted);font-size:13px">Tip: pinch to zoom, drag to pan, double-tap to zoom in.</div> </div> <!-- controls --> <div class="controls" id="controls"> <button id="buyButton" class="controlBtn">Buy Pixels</button> <button id="zoomOut" class="controlBtn small">Zoom −</button> <button id="zoomIn" class="controlBtn small">Zoom +</button> <button id="clearSelection" class="controlBtn small">Clear Sel</button> </div> <!-- minimap --> <div id="minimapWrap"> <canvas id="minimap"></canvas> </div> <!-- magnifier --> <div id="magnifier" style="width:140px;height:140px"></div> <!-- footer/help --> <div class="footer">Mode: <span id="modeLabel">View</span></div> <script> /* ============= Configuration ============= */ const COLS = 1000, ROWS = 1000; // world grid let purchasedPixels = {}; // {'r,c': {link, imageURL}} let selectedPixels = []; // [{row,col,image,link}] const PRICE_PER_PIXEL = 1; /* ============= Canvas & viewport ============= */ const container = document.getElementById('canvasContainer'); const canvas = document.getElementById('pixelCanvas'); const ctx = canvas.getContext('2d', {alpha:false}); const dpi = Math.max(1, window.devicePixelRatio || 1); let scale = 1; // screen px per world cell let minScale = 1, maxScale = 60; let offsetX = 0, offsetY = 0; // in CSS pixels let isDragging = false; let dragStart = {x:0,y:0}; let lastTouchDist = null, lastTouchMid = null; let lastTap = 0; /* helpers */ function resize(){ const w = container.clientWidth, h = container.clientHeight; canvas.style.width = w + 'px'; canvas.style.height = h + 'px'; canvas.width = Math.floor(w * dpi); canvas.height = Math.floor(h * dpi); ctx.setTransform(dpi,0,0,dpi,0,0); // initial fit const fit = Math.min(w / COLS, h / ROWS); if (scale === 1) { scale = fit; minScale = fit; offsetX = (w - COLS*scale)/2; offsetY = (h - ROWS*scale)/2; } constrainView(); draw(); drawMinimap(); } window.addEventListener('resize', resize); /* map screen -> world */ function screenToWorld(clientX, clientY){ const rect = canvas.getBoundingClientRect(); const x = (clientX - rect.left - offsetX) / scale; const y = (clientY - rect.top - offsetY) / scale; return { x, y }; } function worldToCell(x,y){ const col = Math.floor(x), row = Math.floor(y); if (col < 0 || row < 0 || col >= COLS || row >= ROWS) return null; return {row, col}; } /* clamp offsets/scale so we never leave the canvas */ function constrainView(){ const w = canvas.clientWidth, h = canvas.clientHeight; const worldW = COLS * scale, worldH = ROWS * scale; if (worldW <= w) offsetX = (w - worldW)/2; else offsetX = Math.min(0, Math.max(offsetX, w - worldW)); if (worldH <= h) offsetY = (h - worldH)/2; else offsetY = Math.min(0, Math.max(offsetY, h - worldH)); } /* draw only visible cells: compute visible world rectangle and loop that area */ function draw(){ // clear (CSS pixels) ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,canvas.width,canvas.height); ctx.restore(); ctx.save(); ctx.translate(offsetX, offsetY); ctx.scale(scale, scale); // world background ctx.fillStyle = '#0b0b0b'; ctx.fillRect(0,0,COLS,ROWS); // compute visible cells range const w = canvas.clientWidth, h = canvas.clientHeight; const x0 = Math.max(0, Math.floor((-offsetX) / scale)); const y0 = Math.max(0, Math.floor((-offsetY) / scale)); const x1 = Math.min(COLS, Math.ceil((w - offsetX) / scale)); const y1 = Math.min(ROWS, Math.ceil((h - offsetY) / scale)); // draw purchased in visible range ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--purchased').trim() || '#0a8f3a'; for (const key in purchasedPixels){ const [r,c] = key.split(',').map(Number); if (c >= x0 && c < x1 && r >= y0 && r < y1) ctx.fillRect(c, r, 1, 1); } // draw selected ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--selected').trim() || '#16c516'; for (let p of selectedPixels){ if (p.col >= x0 && p.col < x1 && p.row >= y0 && p.row < y1) ctx.fillRect(p.col, p.row, 1, 1); } // hover cell (if buy mode) uses full cover color but only if not purchased if (buyMode && hoveredCell){ const key = ${hoveredCell.row},${hoveredCell.col}; if (!purchasedPixels[key]){ ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--hover').trim() || '#00a3ff'; ctx.fillRect(hoveredCell.col, hoveredCell.row, 1, 1); } } // grid lines (light) for zoomed-in levels if (scale >= 6){ ctx.strokeStyle = 'rgba(0,0,0,0.25)'; ctx.lineWidth = 0.02; ctx.beginPath(); for (let gx = x0; gx <= x1; gx++){ ctx.moveTo(gx, y0); ctx.lineTo(gx, y1); } for (let gy = y0; gy <= y1; gy++){ ctx.moveTo(x0, gy); ctx.lineTo(x1, gy); } ctx.stroke(); } ctx.restore(); drawMinimapViewport(); } /* ============= input / selection ============= */ let buyMode = false; let hoveredCell = null; const buyButton = document.getElementById('buyButton'); const modeLabel = document.getElementById('modeLabel') || document.createElement('span'); buyButton.addEventListener('click', ()=>{ buyMode = !buyMode; buyButton.textContent = buyMode ? 'Exit Buy Mode' : 'Buy Pixels'; document.getElementById('sidebar').classList.toggle('open', buyMode && selectedPixels.length>0); document.getElementById('modeLabel').innerText = buyMode ? 'Buy' : 'View'; if (!buyMode){ selectedPixels = []; updateSidebar(); draw(); } }); /* click selection */ canvas.addEventListener('click', (e)=>{ // ignore if dragging (pan or selection) if (isDragging || boxSelecting) return; const {x,y} = screenToWorld(e.clientX, e.clientY); const cell = worldToCell(x,y); if (!cell) return; const key = ${cell.row},${cell.col}; if (buyMode){ if (purchasedPixels[key]) return; const idx = selectedPixels.findIndex(p=>p.row===cell.row && p.col===cell.col); if (idx>-1) selectedPixels.splice(idx,1); else selectedPixels.push({row:cell.row, col:cell.col, image:null, link:''}); updateSidebar(); draw(); } else { if (purchasedPixels[key]) { // open stored link if any const info = purchasedPixels[key]; if (info && info.link) window.open(info.link,'_blank'); } } }); /* hover highlight (mouse only) */ canvas.addEventListener('mousemove', (e)=>{ if (!buyMode || isDragging || boxSelecting) return; const {x,y} = screenToWorld(e.clientX, e.clientY); const cell = worldToCell(x,y); if (!cell){ if (hoveredCell){ hoveredCell = null; draw(); } return; } if (!hoveredCell || hoveredCell.row !== cell.row || hoveredCell.col !== cell.col){ hoveredCell = cell; draw(); updateMagnifier(e.clientX, e.clientY); } }); /* pan (mouse) */ canvas.addEventListener('mousedown', (e)=>{ if (e.button !== 0) return; if (boxSelectMode && buyMode){ startBoxSelect(e); return; } isDragging = true; dragStart.x = e.clientX - offsetX; dragStart.y = e.clientY - offsetY; }); /* track mouse move for pan */ window.addEventListener('mousemove', (e)=>{ if (isDragging && !boxSelecting){ offsetX = e.clientX - dragStart.x; offsetY = e.clientY - dragStart.y; constrainView(); draw(); drawMinimap(); } }); window.addEventListener('mouseup', ()=>{ isDragging=false; }); /* wheel zoom (desktop) */ canvas.addEventListener('wheel', (e)=>{ e.preventDefault(); const rect = canvas.getBoundingClientRect(); const cx = e.clientX - rect.left, cy = e.clientY - rect.top; const delta = Math.sign(e.deltaY); const zoomFactor = Math.exp(-delta * 0.12); zoomAt(zoomFactor, cx, cy); }, { passive:false }); /* double-tap mobile zoom */ let lastTapTime = 0; canvas.addEventListener('touchend', (e)=>{ const now = Date.now(); if (now - lastTapTime < 300) { // double-tap: zoom in around touch point const t = e.changedTouches[0]; const rect = canvas.getBoundingClientRect(); zoomAt(1.8, t.clientX - rect.left, t.clientY - rect.top); } lastTapTime = now; }); /* pinch zoom + touch pan */ canvas.addEventListener('touchstart', (e)=>{ if (e.touches.length===2){ lastTouchDist = distBetweenTouches(e.touches[0], e.touches[1]); lastTouchMid = midBetweenTouches(e.touches[0], e.touches[1]); } else if (e.touches.length===1){ isDragging = true; dragStart.x = e.touches[0].clientX - offsetX; dragStart.y = e.touches[0].clientY - offsetY; }}, { passive:false }); canvas.addEventListener('touchmove', (e)=>{ e.preventDefault(); if (e.touches.length===1 && isDragging){ offsetX = e.touches[0].clientX - dragStart.x; offsetY = e.touches[0].clientY - dragStart.y; constrainView(); draw(); drawMinimap(); } else if (e.touches.length===2){ const d = distBetweenTouches(e.touches[0], e.touches[1]); const mid = midBetweenTouches(e.touches[0], e.touches[1]); if (lastTouchDist){ const factor = d / lastTouchDist; const rect = canvas.getBoundingClientRect(); zoomAt(factor, mid.x - rect.left, mid.y - rect.top); } lastTouchDist = d; lastTouchMid = mid; } }, { passive:false }); canvas.addEventListener('touchend', (e)=>{ if (e.touches.length < 2) lastTouchDist = null; isDragging = false; }, { passive:false }); function distBetweenTouches(a,b){ return Math.hypot(a.clientX - b.clientX, a.clientY - b.clientY); } function midBetweenTouches(a,b){ return { x:(a.clientX+b.clientX)/2, y:(a.clientY+b.clientY)/2 }; } function zoomAt(factor, cx, cy){ const prev = scale; let next = prev * factor; next = Math.max(minScale, Math.min(maxScale, next)); if (next === prev) return; // world point under cursor const wx = (cx - offsetX) / prev; const wy = (cy - offsetY) / prev; scale = next; offsetX = cx - wx * scale; offsetY = cy - wy * scale; constrainView(); draw(); drawMinimap(); } /* ============= Box select mode (drag rectangle to select many) ============= */ let boxSelectMode = false; let boxSelecting = false; let boxStart = null; let boxRect = null; const boxSelectToggle = document.getElementById('boxSelectToggle'); boxSelectToggle.addEventListener('click', ()=>{ boxSelectMode = !boxSelectMode; boxSelectToggle.textContent = boxSelectMode ? 'Box Select ✓' : 'Box Select'; }); function startBoxSelect(e){ boxSelecting = true; boxStart = {x:e.clientX, y:e.clientY}; boxRect = null; // show temporary overlay via draw loop window.addEventListener('mousemove', trackBoxSelect); window.addEventListener('mouseup', finishBoxSelect, { once:true }); } function trackBoxSelect(e){ const sx = Math.min(boxStart.x, e.clientX), sy = Math.min(boxStart.y, e.clientY); const ex = Math.max(boxStart.x, e.clientX), ey = Math.max(boxStart.y, e.clientY); boxRect = {left:sx, top:sy, right:ex, bottom:ey}; draw(); drawBoxOverlay(); // overlay draws selection rectangle on top } function finishBoxSelect(){ if (!boxRect) { boxSelecting=false; boxStart=null; return; } // convert box rect to world cell range const rect = canvas.getBoundingClientRect(); const x0 = Math.max(0, Math.floor((boxRect.left - rect.left - offsetX) / scale)); const y0 = Math.max(0, Math.floor((boxRect.top - rect.top - offsetY) / scale)); const x1 = Math.min(COLS-1, Math.floor((boxRect.right - rect.left - offsetX) / scale)); const y1 = Math.min(ROWS-1, Math.floor((boxRect.bottom - rect.top - offsetY) / scale)); for (let r=y0;r<=y1;r++){ for (let c=x0;c<=x1;c++){ const key = ${r},${c}; if (purchasedPixels[key]) continue; if (!selectedPixels.find(s=>s.row===r && s.col===c)) selectedPixels.push({row:r,col:c,image:null,link:''}); } } boxSelecting=false; boxStart=null; boxRect=null; window.removeEventListener('mousemove', trackBoxSelect); updateSidebar(); draw(); } /* draw selection rectangle overlay */ function drawBoxOverlay(){ if (!boxRect) return; ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.strokeStyle = 'rgba(0,163,255,0.9)'; ctx.lineWidth = 2; ctx.strokeRect(boxRect.left - canvas.getBoundingClientRect().left, boxRect.top - canvas.getBoundingClientRect().top, boxRect.right - boxRect.left, boxRect.bottom - boxRect.top); ctx.restore(); } /* ============= Sidebar UI ============= */ function updateSidebar(){ const sidebarEl = document.getElementById('sidebar'); const has = selectedPixels.length > 0; sidebarEl.classList.toggle('open', has); pixelList.innerHTML = ''; selectedPixels.forEach((p,i)=>{ const div = document.createElement('div'); div.className='pixelSection'; div.innerHTML = <button class="removePixel" data-index="${i}">×</button> <img src="${p.image||'https://via.placeholder.com/56'}" alt=""> <div class="pixelMeta"> <div style="font-size:13px">Row: <strong>${p.row}</strong> &nbsp; Col: <strong>${p.col}</strong></div> <input type="file" class="imageInput" data-index="${i}" accept="image/*"/> <input type="url" class="linkInput" data-index="${i}" placeholder="https://example.com" value="${p.link||''}" /> </div>; const rem = div.querySelector('.removePixel'); rem.addEventListener('click', ()=>{ selectedPixels.splice(i,1); updateSidebar(); draw(); }); // hover highlight when hovering in sidebar div.addEventListener('mouseenter', ()=>{ hoveredCell = {row:p.row,col:p.col}; draw(); }); div.addEventListener('mouseleave', ()=>{ hoveredCell = null; draw(); }); pixelList.appendChild(div); }); // toggle link inputs document.querySelectorAll('.linkInput').forEach(inp=>inp.style.display = singleLinkCheckbox.checked ? 'none':'block'); totalCostEl.innerText = Total Cost: ${selectedPixels.length} JOD; } /* handle file/link changes (delegation) */ pixelList.addEventListener('change', (e)=>{ const idx = parseInt(e.target.dataset.index); if (e.target.classList.contains('imageInput')){ const file = e.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (ev)=>{ selectedPixels[idx].image = ev.target.result; updateSidebar(); }; reader.readAsDataURL(file); } else if (e.target.classList.contains('linkInput')){ selectedPixels[idx].link = e.target.value.trim(); } }); /* bulk apply (single image + link to all) */ document.getElementById('bulkApply').addEventListener('click', ()=>{ if (selectedPixels.length === 0) return alert('Select pixels first'); const fileInput = document.createElement('input'); fileInput.type='file'; fileInput.accept='image/*'; fileInput.onchange = ()=> { const f = fileInput.files[0]; if (!f) return; const reader = new FileReader(); reader.onload = ()=> { for (let p of selectedPixels) p.image = reader.result; const link = prompt('Enter common hyperlink for all selected pixels (or leave empty):'); if (link !== null) selectedPixels.forEach(p=>p.link = link.trim()); updateSidebar(); }; reader.readAsDataURL(f); }; fileInput.click(); }); /* checkout action (placeholder to hookup backend / payment) */ document.getElementById('checkout').addEventListener('click', ()=>{ if (selectedPixels.length === 0) return alert('No pixels selected'); if (singleLinkCheckbox.checked){ const link = prompt('Enter hyperlink for ALL selected pixels:'); if (link === null) return; selectedPixels.forEach(p=>p.link = link.trim()); } // Build payload const payload = selectedPixels.map(p=>({row:p.row,col:p.col,link:p.link,image:p.image})); console.log('Ready to send to server/payment:', payload); alert((Demo) Purchased ${selectedPixels.length} pixel(s) — check console for payload.); // mark them purchased locally (demo). In real site, send to backend and on success update purchasedPixels. for (const p of selectedPixels){ purchasedPixels[${p.row},${p.col}] = {link:p.link||'', image:p.image||''}; } selectedPixels = []; updateSidebar(); draw(); }); /* ============= Minimap ============= */ const minimap = document.getElementById('minimap'); const mctx = minimap.getContext('2d'); function drawMinimap(){ const mw = minimap.width = minimap.clientWidth * dpi; const mh = minimap.height = minimap.clientHeight * dpi; mctx.setTransform(dpi,0,0,dpi,0,0); mctx.clearRect(0,0,minimap.clientWidth,minimap.clientHeight); // background mctx.fillStyle = '#070707'; mctx.fillRect(0,0,minimap.clientWidth,minimap.clientHeight); // draw a quick purchased pixel thumbnail (sparse) -> we'll just draw few random for demo; for real use, fetch aggregated blocks or scaled image mctx.fillStyle = '#0a8f3a'; // if many purchased, this loop might be heavy; we only draw bounding rect of purchased for demonstration // draw view rectangle const viewLeft = (-offsetX) / scale / COLS * minimap.clientWidth; const viewTop = (-offsetY) / scale / ROWS * minimap.clientHeight; const viewW = (canvas.clientWidth) / scale / COLS * minimap.clientWidth; const viewH = (canvas.clientHeight) / scale / ROWS * minimap.clientHeight; mctx.strokeStyle = '#00a3ff'; mctx.lineWidth=2; mctx.strokeRect(viewLeft, viewTop, viewW, viewH); } /* interact with minimap: click to jump view; drag the rectangle */ let minimapDragging=false; minimap.addEventListener('mousedown', (e)=>{ minimapDragging = true; panToMinimap(e); }); window.addEventListener('mousemove', (e)=>{ if (minimapDragging) panToMinimap(e); }); window.addEventListener('mouseup', ()=>minimapDragging=false); function panToMinimap(e){ const rect = minimap.getBoundingClientRect(); const cx = e.clientX - rect.left; const cy = e.clientY - rect.top; const worldX = cx / minimap.clientWidth * COLS; const worldY = cy / minimap.clientHeight * ROWS; const w = canvas.clientWidth, h = canvas.clientHeight; // center view on worldX, worldY offsetX = (w/2) - worldX*scale; offsetY = (h/2) - worldY*scale; constrainView(); draw(); drawMinimap(); } /* draw minimap viewport updated after draw */ function drawMinimapViewport(){ drawMinimap(); } /* ============= Magnifier ============= */ const magnifier = document.getElementById('magnifier'); function updateMagnifier(clientX, clientY){ const size = 140; const zoom = Math.max(3, Math.min(12, Math.round(scale))); magnifier.style.width = size + 'px'; magnifier.style.height = size + 'px'; magnifier.style.left = (clientX + 14) + 'px'; magnifier.style.top = (clientY + 14) + 'px'; magnifier.style.display = 'block'; // draw small zoomed view const mctx2 = magnifier.querySelector('canvas') ? magnifier.querySelector('canvas').getContext('2d') : null; if (!mctx2){ const c = document.createElement('canvas'); c.width=c.height= size * dpi; c.style.width=size+'px'; c.style.height=size+'px'; c.getContext('2d').setTransform(dpi,0,0,dpi,0,0); magnifier.appendChild(c); } const c = magnifier.querySelector('canvas'); const mc = c.getContext('2d'); // compute world coordinate under cursor const world = screenToWorld(clientX, clientY); const sx = (world.x - 10) * scale + offsetX; const sy = (world.y - 10) * scale + offsetY; // draw a portion from main canvas onto magnifier via drawImage mc.save(); mc.clearRect(0,0,c.width/dpi,c.height/dpi); mc.drawImage(canvas, (sx)*dpi, (sy)*dpi, (20*scale)*dpi, (20*scale)*dpi, 0,0, c.width/dpi,c.height/dpi); mc.restore(); } canvas.addEventListener('mouseenter', (e)=>{ if (buyMode) updateMagnifier(e.clientX,e.clientY); }); canvas.addEventListener('mousemove', (e)=>{ if (buyMode) updateMagnifier(e.clientX,e.clientY); }); canvas.addEventListener('mouseleave', ()=>{ magnifier.style.display='none'; }); /* ============= keyboard shortcuts ============= */ window.addEventListener('keydown', (e)=>{ if (e.key === 'Escape'){ buyMode = false; document.getElementById('sidebar').classList.remove('open'); selectedPixels=[]; updateSidebar(); draw(); } if (e.key === '+' || e.key === '=') zoomAt(1.2, canvas.clientWidth/2, canvas.clientHeight/2); if (e.key === '-') zoomAt(1/1.2, canvas.clientWidth/2, canvas.clientHeight/2); }); /* full screen */ document.getElementById('fsBtn').addEventListener('click', ()=>{ if (!document.fullscreenElement) container.requestFullscreen().catch(()=>{}); else document.exitFullscreen(); }); /* helper: zoomAt (public) */ function zoomAt(factor, cx, cy){ const prev=scale; let next = prev * factor; next=Math.max(minScale,Math.min(maxScale,next)); if (next===prev) return; const wx = (cx - offsetX) / prev, wy = (cy - offsetY) / prev; scale = next; offsetX = cx - wx*scale; offsetY = cy - wy*scale; constrainView(); draw(); drawMinimap(); } /* clear selection button */ document.getElementById('clearSelection').addEventListener('click', ()=>{ selectedPixels=[]; updateSidebar(); draw(); }); /* zoom buttons */ document.getElementById('zoomIn').addEventListener('click', ()=>zoomAt(1.25, canvas.clientWidth/2, canvas.clientHeight/2)); document.getElementById('zoomOut').addEventListener('click', ()=>zoomAt(1/1.25, canvas.clientWidth/2, canvas.clientHeight/2)); /* init */ resize(); draw(); drawMinimap(); /* expose draw for other contexts (already used) */ window.MillionPixel = { draw, selectedPixels, purchasedPixels }; // debug </script> </body> </html>
