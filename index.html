<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Million Pixel — Grid</title>
<style>
:root{
  --bg:#0f0f10; --panel:#141416; --accent:#0f0; --muted:#7b7b7b;
  --avail:#333; --purchased:#0a8f3a; --selected:#16c516; --hover:#00a3ff;
}
*{box-sizing:border-box}
body{margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:var(--bg);color:#eee;overflow:hidden}
nav{position:fixed;left:0;right:0;top:0;height:56px;background:#151515;display:flex;align-items:center;padding:8px 12px;z-index:40}
nav img{height:34px;margin-right:10px}
nav h1{color:var(--accent);font-size:18px;margin:0 14px 0 0}
nav .spacer{flex:1}
button, input, select, textarea{font-family:inherit;font-size:14px}

/* canvas area */
#canvasContainer{position:absolute;top:56px;left:0;right:0;bottom:0;background:var(--bg);overflow:hidden}
canvas{display:block; width:100%; height:100%; background:transparent; cursor:crosshair}

/* sidebar */
#sidebar{position:fixed;top:56px;right:-360px;width:360px;bottom:0;background:var(--panel);border-left:1px solid #222;padding:12px;overflow-y:auto;transition:right .25s;z-index:45}
#sidebar.open{right:0}
#sidebar h2{margin:6px 0 10px 0}

/* pixel item */
.pixelSection{display:flex;gap:8px;align-items:flex-start;border:1px solid #222;padding:8px;border-radius:8px;margin-bottom:8px;background:#111;position:relative}
.pixelSection img{width:56px;height:56px;object-fit:cover;border-radius:4px}
.pixelMeta{flex:1;font-size:13px}
.pixelMeta input{width:100%;margin-top:6px;padding:6px;border-radius:6px;border:1px solid #222;background:#0b0b0b;color:#fff}
.removePixel{position:absolute;top:6px;right:6px;background:#cc3333;border:none;color:#fff;border-radius:50%;width:24px;height:24px;cursor:pointer}

/* small controls */
.controls{position:fixed;top:64px;right:380px;z-index:46;display:flex;flex-direction:column;gap:8px}
.controlBtn{background:var(--accent);color:#0b0b0b;border:none;padding:10px 12px;border-radius:8px;cursor:pointer}
.small{padding:8px 10px;font-size:13px}

/* minimap */
#minimapWrap{position:fixed;left:12px;bottom:12px;background:rgba(0,0,0,0.45);padding:8px;border-radius:8px;border:1px solid #222;z-index:46}
#minimap{width:160px;height:160px;display:block;background:#0b0b0b;border-radius:4px}

/* magnifier */
#magnifier{position:fixed;pointer-events:none;z-index:50;border-radius:8px;overflow:hidden;border:2px solid rgba(255,255,255,0.08);display:none;background:#000}

/* footer/help */
.footer{position:fixed;left:12px;top:12px;background:rgba(0,0,0,0.35);padding:6px 10px;border-radius:6px;border:1px solid #222;font-size:13px;z-index:46}
</style>
</head>
<body>

<nav>
  <img src="https://via.placeholder.com/34" alt="logo">
  <h1>Million Pixel</h1>
  <div class="spacer"></div>
  <button id="fsBtn" class="small">Full screen</button>
</nav>

<div id="canvasContainer">
  <canvas id="pixelCanvas"></canvas>
</div>

<!-- sidebar -->
<div id="sidebar" aria-hidden="true">
  <h2>Selected Pixels</h2>
  <label style="display:flex;align-items:center;gap:8px;margin-bottom:8px">
    <input type="checkbox" id="singleLink"> Use one website URL for all pixels
  </label>

  <div style="display:flex;gap:8px;margin-bottom:8px">
    <button id="bulkApply" class="controlBtn">Bulk apply image/link</button>
    <button id="boxSelectToggle" class="controlBtn">Box Select</button>
    <button id="applySameImage" class="controlBtn">Same Image All</button>
  </div>

  <div id="pixelList"></div>

  <div id="totalCost" style="margin-top:8px;font-weight:700">Total Cost: 0 JOD</div>
  <button id="checkout" style="margin-top:10px;padding:10px;border-radius:8px;border:none;background:var(--accent);color:#000;font-weight:700">Checkout</button>
  <div style="margin-top:12px;color:var(--muted);font-size:13px">Tip: pinch to zoom, drag to pan, double-tap to zoom in.</div>
</div>

<!-- controls -->
<div class="controls" id="controls">
  <button id="buyButton" class="controlBtn">Buy Pixels</button>
  <button id="zoomOut" class="controlBtn small">Zoom −</button>
  <button id="zoomIn" class="controlBtn small">Zoom +</button>
  <button id="clearSelection" class="controlBtn small">Clear Sel</button>
  <button id="sliceToggle" class="controlBtn small">Slice Tool</button>
</div>

<!-- minimap -->
<div id="minimapWrap">
  <canvas id="minimap"></canvas>
</div>

<!-- magnifier -->
<div id="magnifier" style="width:140px;height:140px"></div>

<!-- footer/help -->
<div class="footer">Mode: <span id="modeLabel">View</span></div>

<script>
/* ============= Configuration ============= */
const COLS = 1000, ROWS = 1000;
let purchasedPixels = {};
let selectedPixels = [];
const PRICE_PER_PIXEL = 1;

/* ============= Canvas & viewport ============= */
const container = document.getElementById('canvasContainer');
const canvas = document.getElementById('pixelCanvas');
const ctx = canvas.getContext('2d', {alpha:false});
const dpi = Math.max(1, window.devicePixelRatio || 1);

let scale = 1;
let minScale = 1, maxScale = 60;
let offsetX = 0, offsetY = 0;
let isDragging = false;
let dragStart = {x:0,y:0};
let lastTouchDist = null, lastTouchMid = null;
let lastTap = 0;

/* helpers */
function resize(){
  const w = container.clientWidth, h = container.clientHeight;
  canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
  canvas.width = Math.floor(w * dpi); canvas.height = Math.floor(h * dpi);
  ctx.setTransform(dpi,0,0,dpi,0,0);
  const fit = Math.min(w / COLS, h / ROWS);
  if (scale === 1) { scale = fit; minScale = fit; offsetX = (w - COLS*scale)/2; offsetY = (h - ROWS*scale)/2; }
  constrainView(); draw(); drawMinimap();
}
window.addEventListener('resize', resize);

/* map screen -> world */
function screenToWorld(clientX, clientY){
  const rect = canvas.getBoundingClientRect();
  const x = (clientX - rect.left - offsetX) / scale;
  const y = (clientY - rect.top  - offsetY) / scale;
  return { x, y };
}
function worldToCell(x,y){
  const col = Math.floor(x), row = Math.floor(y);
  if (col < 0 || row < 0 || col >= COLS || row >= ROWS) return null;
  return {row, col};
}

/* clamp offsets/scale */
function constrainView(){
  const w = canvas.clientWidth, h = canvas.clientHeight;
  const worldW = COLS * scale, worldH = ROWS * scale;
  if (worldW <= w) offsetX = (w - worldW)/2;
  else offsetX = Math.min(0, Math.max(offsetX, w - worldW));
  if (worldH <= h) offsetY = (h - worldH)/2;
  else offsetY = Math.min(0, Math.max(offsetY, h - worldH));
}

/* draw canvas */
function draw(){
  ctx.save(); ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.scale(scale,scale);
  ctx.translate(offsetX/scale, offsetY/scale);

  // draw grid
  ctx.fillStyle = '#111';
  ctx.fillRect(0,0,COLS,ROWS);

  // purchased pixels
  ctx.fillStyle = 'green';
  for (let key in purchasedPixels){
    const [r,c] = key.split(',').map(Number);
    ctx.fillRect(c,r,1,1);
  }

  // selected pixels
  ctx.fillStyle = 'rgba(0,200,0,0.5)';
  selectedPixels.forEach(p=>{
    ctx.fillRect(p.col,p.row,1,1);
    if (p.image){
      const img = new Image();
      img.src = p.image;
      ctx.drawImage(img, p.col, p.row, 1, 1);
    }
  });

  ctx.restore();
  drawSliceOverlay();
}

/* ============= Sidebar ============= */
const sidebar = document.getElementById('sidebar');
function updateSidebar(){
  const list = document.getElementById('pixelList');
  list.innerHTML = '';
  selectedPixels.forEach((p,i)=>{
    const div = document.createElement('div');
    div.className='pixelSection';
    div.innerHTML=`<div class="pixelMeta">Row: ${p.row} Col: ${p.col}</div>
      <input type="text" placeholder="URL" value="${p.link||''}" data-index="${i}" class="linkInput">
      <button class="removePixel" data-index="${i}">&times;</button>`;
    if (p.image){
      const imgEl = document.createElement('img'); imgEl.src = p.image;
      div.insertBefore(imgEl, div.firstChild);
    }
    list.appendChild(div);
  });

  // remove handler
  list.querySelectorAll('.removePixel').forEach(btn=>{
    btn.onclick=()=>{selectedPixels.splice(btn.dataset.index,1);updateSidebar();draw();}
  });
  list.querySelectorAll('.linkInput').forEach(inp=>{
    inp.oninput = ()=>{selectedPixels[inp.dataset.index].link=inp.value;}
  });

  const cost = selectedPixels.length * PRICE_PER_PIXEL;
  document.getElementById('totalCost').textContent = `Total Cost: ${cost} JOD`;
}

/* ============= Slice Tool ============= */
let sliceMode = false;
let sliceSelecting = false;
let sliceStart = null;
let sliceRect = null;

const sliceToggle = document.getElementById('sliceToggle');
sliceToggle.addEventListener('click', ()=>{
  sliceMode = !sliceMode;
  sliceToggle.textContent = sliceMode ? "Slice Tool ✓" : "Slice Tool";
});

canvas.addEventListener('mousedown', (e)=>{
  if (sliceMode){
    sliceSelecting = true;
    sliceStart = {x:e.clientX, y:e.clientY};
    sliceRect = null;
    window.addEventListener('mousemove', trackSlice);
    window.addEventListener('mouseup', finishSlice, {once:true});
  }
});

function trackSlice(e){
  if (!sliceSelecting) return;
  const sx = Math.min(sliceStart.x, e.clientX), sy = Math.min(sliceStart.y, e.clientY);
  const ex = Math.max(sliceStart.x, e.clientX), ey = Math.max(sliceStart.y, e.clientY);
  sliceRect = {left:sx, top:sy, right:ex, bottom:ey};
  draw(); drawSliceOverlay();
}

function finishSlice(){
  if (!sliceRect){ sliceSelecting=false; return; }
  const rect = canvas.getBoundingClientRect();
  const x0 = Math.max(0, Math.floor((sliceRect.left - rect.left - offsetX) / scale));
  const y0 = Math.max(0, Math.floor((sliceRect.top  - rect.top  - offsetY) / scale));
  const x1 = Math.min(COLS-1, Math.floor((sliceRect.right - rect.left - offsetX) / scale));
  const y1 = Math.min(ROWS-1, Math.floor((sliceRect.bottom - rect.top - offsetY) / scale));
  for (let r=y0;r<=y1;r++){
    for (let c=x0;c<=x1;c++){
      const key = `${r},${c}`;
      if (purchasedPixels[key]) continue;
      if (!selectedPixels.find(s=>s.row===r && s.col===c))
        selectedPixels.push({row:r,col:c,image:null,link:''});
    }
  }
  sliceSelecting=false; sliceStart=null; sliceRect=null;
  window.removeEventListener('mousemove', trackSlice);
  updateSidebar(); draw();
}

function drawSliceOverlay(){
  if (!sliceRect) return;
  ctx.save();
  ctx.setTransform(1,0,0,1,0,0);
  ctx.strokeStyle = 'rgba(255,200,0,0.9)';
  ctx.lineWidth = 2;
  ctx.strokeRect(
    sliceRect.left - canvas.getBoundingClientRect().left,
    sliceRect.top - canvas.getBoundingClientRect().top,
    sliceRect.right - sliceRect.left,
    sliceRect.bottom - sliceRect.top
  );
  ctx.restore();
}

/* ============= Apply same image to all ============= */
const applySameImageBtn = document.getElementById('applySameImage');
applySameImageBtn.addEventListener('click', ()=>{
  const input = document.createElement('input');
  input.type = 'file'; input.accept = 'image/*';
  input.onchange = (e)=>{
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev)=>{
      for (let p of selectedPixels){
        p.image = ev.target.result;
      }
      updateSidebar(); draw();
    };
    reader.readAsDataURL(file);
  };
  input.click();
});

/* ============= Controls ============= */
document.getElementById('zoomIn').addEventListener('click', ()=>{scale=Math.min(maxScale,scale*1.25);constrainView();draw();});
document.getElementById('zoomOut').addEventListener('click', ()=>{scale=Math.max(minScale,scale*0.8);constrainView();draw();});
document.getElementById('clearSelection').addEventListener('click', ()=>{selectedPixels=[];updateSidebar();draw();});
document.getElementById('buyButton').addEventListener('click', ()=>{sidebar.classList.toggle('open');});
document.getElementById('fsBtn').addEventListener('click', ()=>{document.documentElement.requestFullscreen();});

/* ============= Minimap ============= */
const minimap = document.getElementById('minimap');
const mctx = minimap.getContext('2d');
function drawMinimap(){
  mctx.fillStyle='#000'; mctx.fillRect(0,0,minimap.width,minimap.height);
  const sx = minimap.width/COLS, sy = minimap.height/ROWS;
  mctx.fillStyle='green';
  for (let key in purchasedPixels){
    const [r,c] = key.split(',').map(Number);
    mctx.fillRect(c*sx, r*sy, sx, sy);
  }
}

/* initialize */
resize();
</script>
</body>
</html>
